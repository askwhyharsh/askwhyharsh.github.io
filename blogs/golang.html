<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Understanding Race Conditions and Mutexes in Go</title>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  </head>
  <body class="bg-green-50 w-full max-w-[95%] md:w-[60%] mx-auto">
    <nav class="mt-6">
      <div>
        <h1 class="font-serif text-4xl">Harsh's Blog</h1>
        <div class="mt-5 flex flex-wrap gap-5">
          <a
            href="../index.html"
            class="relative after:content-[''] after:absolute after:w-0 after:h-[2px] after:bg-black after:bottom-[-4px] after:left-0 hover:after:w-full after:transition-all after:duration-300"
            >Home</a
          >
          <a
            href="./blog.html"
            class="relative after:content-[''] after:absolute after:w-0 after:h-[2px] after:bg-black after:bottom-[-4px] after:left-0 hover:after:w-full after:transition-all after:duration-300"
            >Blogs</a
          >
          <a
            href="../maths/maths.html"
            class="relative after:content-[''] after:absolute after:w-0 after:h-[2px] after:bg-black after:bottom-[-4px] after:left-0 hover:after:w-full after:transition-all after:duration-300"
            >Maths</a
          >
        </div>
      </div>
    </nav>

    <hr class="mt-3" />

    <h1 class="text-4xl mt-[57px] mb-3 font-serif">
      Understanding Race Conditions and Mutexes in Go
    </h1>
    <span class="text-sm text-gray-500">Published Date</span>

    <p class="text-lg font-serif mt-6">
      It's been quite some time since I picked up Go, and I've built a flex-wrap projects with it (a simple blockchain, p2p file storage, and <a href="https://github.com/askwhyharsh/neartalk" class="underline">neartalk</a>). With each project, I find myself liking Go more :D - I think the language really does everything right for what it's made for. It's simple and it's great (and quite fast). Yes, concurrency is quite nice, but when multiple goroutines access shared data simultaneously, things can go wrong fast, although no problem as we can solve this with mutexes. 
      <p class="text-lg font-serif mt-4">In this blog, I want to share what I have learned about goroutines, channels, race conditions and mutexes.</p>
    </p>

    <h1 class="text-2xl font-serif mt-8">What is Concurrency?</h1>

    <p class="text-lg font-serif mt-4">
      So concurrency is about dealing with multiple things at once. In Go, we achieve this through <span class="font-bold">goroutines</span> - lightweight threads managed by the Go runtime.
    </p>

    <pre><code class="language-go">go doSomething()  // runs concurrently</code></pre>

    <p class="text-lg font-serif mt-4">
      Think of concurrency like a chef managing multiple dishes:
    </p>
    <ul class="text-lg font-serif mt-2 ml-6 list-disc">
      <li>The chef switches between stirring soup, checking the oven, and chopping vegetables</li>
      <li>They're not doing everything simultaneously, but managing multiple tasks efficiently</li>
      <li>This is concurrency: dealing with lots of things at once</li>
    </ul>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>Single Goroutine:          Multiple Goroutines:
    Task A                     Task A    Task B    Task C
    Task B                       |         |         |
    Task C                       v         v         v
      |                       [Running Concurrently]
      v                              
   [Sequential]                  Time Saved!</code></pre>

    <h1 class="text-2xl font-serif mt-8">Concurrency vs Parallelism</h1>

    <p class="text-lg font-serif mt-4">
       Concurrency is NOT the same as parallelism
    </p>

    <ul class="text-lg font-serif mt-2 ml-6 list-disc">
      <li>Concurrency = Structure (how you design your program to handle multiple tasks)</li>
      <li>Parallelism = Execution (actually running multiple tasks at the exact same time)</li>
    </ul>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>Concurrency (1 CPU):          Parallelism (2+ CPUs):
    
    Task A  Task B                Task A    Task B
      |       |                      |         |
      v       |                      v         v
      |       v                   [CPU 1]   [CPU 2]
      v       |                      |         |
      |       v                      v         v
   [Switching back and            [Both running simultaneously!]
    forth on single CPU]               
    </code></pre>

    <p class="text-lg font-serif mt-4">
      Go's runtime scheduler can run goroutines concurrently on a single CPU core, or in parallel across multiple cores. You write concurrent code, and Go handles making it parallel when possible!
    </p>

    <h1 class="text-2xl font-serif mt-8">Race Conditions</h1>

    <p class="text-lg font-serif mt-4">
      A race condition occurs when multiple goroutines access shared data simultaneously, and at least one of them is writing. The outcome depends on the unpredictable timing of their execution.
    </p>
    <p class="text-lg font-serif mt-4">
        e.g., if one thread tries to increase an integer and another thread tries to read it, this will cause a race condition. On the other hand, if the variable is read-only, there won't be a race condition.
        Let's try to create a race condition. The easiest way to do it is by using multiple goroutines, and at least one of the goroutines must be writing to a shared variable.
    </p>

    <h1 class="text-xl font-serif mt-6">Classic e.g: The Bank Account Problem</h1>

    <p class="text-lg font-serif mt-4">
      Imagine two people trying to withdraw money from the same account at the exact same time:
    </p>

    <pre><code class="language-go">var balance = 100

func withdraw(amount int) {
    if balance >= amount {
        // What if another goroutine runs here?
        balance = balance - amount
    }
}

// Two goroutines run simultaneously
go withdraw(60)
go withdraw(60)</code></pre>

    <p class="text-lg font-serif mt-4">
      <span class="font-bold">What could go wrong?</span>
    </p>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>Time    Goroutine 1          Goroutine 2          Balance
----    -----------          -----------          -------
t1      Read balance=100                          100
t2                           Read balance=100     100
t3      Check: 100>=60 ✓                          100
t4                           Check: 100>=60 ✓     100
t5      balance = 100-60                          40
t6                           balance = 100-60     40</code></pre>

    <p class="text-lg font-serif mt-4">
      <span class="font-bold">Result:</span> Balance is 40, but we withdrew 120
    </p>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>(Race Condition):
┌─────────────┐         ┌─────────────┐
│ Goroutine 1 │         │ Goroutine 2 │
└──────┬──────┘         └──────┬──────┘
       │                       │
       │  Read: balance=100    │
       ├───────────────────────┤
       │                       │ Read: balance=100
       │                       ├───────────────────
       │  Write: balance=40    │
       ├───────────────────────┤
       │                       │ Write: balance=40  X
       │                       │
       ▼                       ▼
   [Data Corruption!]</code></pre>

    <h1 class="text-2xl font-serif mt-8">Solution: Mutexes</h1>

    <p class="text-lg font-serif mt-4">
      A <span class="font-bold">So a Mutex</span> (mutual exclusion) is like a lock on a door. Only one goroutine can hold the lock at a time.
    </p>
    <p class="text-lg font-serif mt-4">
        Let's see with an example:
    </p>

    <pre><code class="language-go">import "sync"

var (
    balance = 100
    mu      sync.Mutex  // Our lock
)

func withdraw(amount int) {
    mu.Lock()           // Lock the door
    defer mu.Unlock()   // Unlock when done
    
    if balance >= amount {
        balance = balance - amount
    }
}</code></pre>

    <h1 class="text-xl font-serif mt-6">How Mutexes Work : Under the hood</h1>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>With Mutex Protection:
┌─────────────┐         ┌─────────────┐
│ Goroutine 1 │         │ Goroutine 2 │
└──────┬──────┘         └──────┬──────┘
       │                       │
       │  Lock() ✓             │
       ├───────────────────────┤
       │  Read: balance=100    │
       │  Write: balance=40    │ Lock() ⏳ [Waiting...]
       │  Unlock()             │
       ├───────────────────────┤
       │                       │ Lock() ✓
       │                       │ Read: balance=40
       │                       │ Check: 40>=60 ✗
       │                       │ Unlock()
       ▼                       ▼
   [Safe! Balance=40]</code></pre>

    <h1 class="text-2xl font-serif mt-8">RWMutex: Optimizing Reads</h1>

    <p class="text-lg font-serif mt-4">
      Sometimes many goroutines just want to <em>read</em> data, which is actually safe. <span class="font-bold">RWMutex</span> allows multiple readers OR one writer.
    </p>

    <pre><code class="language-go">var (
    balance = 100
    mu      sync.RWMutex
)

func getBalance() int {
    mu.RLock()          // Read lock (multiple allowed)
    defer mu.RUnlock()
    return balance
}

func deposit(amount int) {
    mu.Lock()           // Write lock (exclusive)
    defer mu.Unlock()
    balance += amount
}</code></pre>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>RWMutex Behavior:

Multiple Readers (Allowed):
┌─────────┐  ┌─────────┐  ┌─────────┐
│ Reader1 │  │ Reader2 │  │ Reader3 │
│ RLock() │  │ RLock() │  │ RLock() │
└────┬────┘  └────┬────┘  └────┬────┘
     └────────┴────────┴────────┘
              All read safely!

One Writer (Exclusive):
┌─────────┐                ┌─────────┐
│ Writer  │                │ Reader  │
│ Lock()  │                │ RLock() │ ⏳ Blocked
└────┬────┘                └─────────┘
     │ Exclusive access
     │ No one else allowed!</code></pre>

    <h1 class="text-2xl font-serif mt-8">Channels</h1>

    <p class="text-lg font-serif mt-4">
      While mutexes protect shared memory, <span class="font-bold">channels</span> let goroutines communicate by passing data.
    </p>

    <h1 class="text-xl font-serif mt-6">Basic Channel Usage</h1>

    <pre><code class="language-go">ch := make(chan int)

// Sender goroutine
go func() {
    ch <- 42  // Send value to channel
}()

// Receiver
value := <-ch  // Receive value from channel</code></pre>

    <h1 class="text-xl font-serif mt-6">How Channels Work</h1>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>Unbuffered Channel (Synchronous):

Sender                    Channel                  Receiver
  │                          │                        │
  │  ch <- 42                │                        │
  ├─────────────────────────>│                        │
  │  [BLOCKED]               │                        │
  │                          │    value := <-ch       │
  │                          │<───────────────────────┤
  │  [UNBLOCKED]             │                        │
  │                          │  value = 42            │
  │                          │                        │
  
Buffered Channel (buffer=2):

Sender                    Channel                  Receiver
  │                       [  ][  ]                    │
  │  ch <- 1                 ↓                          │
  │  ch <- 2               [1][2]                        │
  │  [No blocking yet!]      │                          │
  │  ch <- 3                 │                          │
  │  [BLOCKED - full]      [1][2]                        │
  │                          │    value := <-ch         │
  │                          │    (gets 1)              │
  │  [UNBLOCKED]           [2][ ]                        │
  │  (sent 3)              [2][3]</code></pre>


    <p class="text-lg font-serif mt-4">
      <span class="font-bold">We use Mutexes when:</span> we need to protect shared data from concurrent access
    </p>
    <ul class="text-lg font-serif mt-2 ml-6 list-disc">
      <li>Protecting simple state (counters, flags, data structures)</li>
      <li>Very quick operations</li>
    </ul>

    <p class="text-lg font-serif mt-4">
      The code below is an example of how to use a mutex to protect a counter. Check the increment function. If we remove the mutex, the counter will be corrupted (race condition)
    </p>

    <pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

// Mutex Example: Protecting a counter
var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

func main() {
    // Multiple goroutines incrementing the counter
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Println("Counter:", counter)  // Will always be 1000 (without mutex)
    
}</code></pre>


    <h1 class="text-2xl font-serif mt-8">Detecting Race Conditions</h1>

    <p class="text-lg font-serif mt-4">
      Go has a built-in race detector! Use it during development:
    </p>

    <pre><code class="language-bash">go run -race main.go
go test -race ./...</code></pre>

    <p class="text-lg font-serif mt-4">
      The race detector will catch issues like:
    </p>

    <pre class="bg-green-50 p-4 rounded my-6 overflow-x-auto"><code>WARNING: DATA RACE
Write at 0x00c000018090 by goroutine 7:
  main.withdraw()
      /path/to/main.go:15 +0x44

Previous read at 0x00c000018090 by goroutine 6:
  main.withdraw()
      /path/to/main.go:14 +0x3a</code></pre>

    <h1 class="text-2xl font-serif mt-8">Best Practices</h1>

    <p class="text-lg font-serif mt-4">
      From what I have read and learned so far:
    </p>

    <p class="text-lg font-serif mt-4">
      1. Always use defer with Unlock
    </p>
    <pre><code class="language-go">mu.Lock()
defer mu.Unlock()  // Ensures unlock even if panic occurs</code></pre>

        <br />

    <p class="text-lg font-serif mt-4">
      2. Keep critical sections small
    </p>
    <pre><code class="language-go">// Bad: Long critical section
mu.Lock()
doLotsOfWork()
mu.Unlock()

// Good: Minimal critical section
doLotsOfWork()
mu.Lock()
updateSharedState()
mu.Unlock()</code></pre>

    <br />

    <p class="text-lg font-serif mt-4">
      3. Avoid nested locks (can cause deadlocks)
    </p>
    <pre><code class="language-go">// Dangerous!
mu1.Lock()
mu2.Lock()  // What if another goroutine locks in reverse order?
mu2.Unlock()
mu1.Unlock()</code></pre>


    <p class="text-lg font-serif mt-6">
      So I think that's about it. I wrote this one because I have been working with Go for quite some time, and wanted to write down my understanding of it. I am here to learn, if you feel something's wrong or missing, please let me know at <a href="mailto:askwhyharsh@gmail.com" class="underline font-semibold">askwhyharsh@gmail.com</a>.
    </p>

    <hr class="my-10" />
    <footer class="my-8">
      <div class="flex justify-between items-center">
        <p>By Harsh</p>
      </div>
    </footer>
  </body>
</html>

